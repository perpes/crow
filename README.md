# Crow

Crow is a trustless autonomous escrow dApp for digitized problems set by problem setters and solved by problem solvers. Problem setters set their problems digitally as described below, and the problem solvers try to solve them. Once Crow confirms the solution, it exchanges the code provided by the solver, with the reward provided by the setter.

### TL;DR

**Stage 1 (`0.0.x`):** Crow begins with escrowing digitally verifiable services/products.

**Stage 2 (`0.x.x`):** Crow introduces escrowing simple physical services/products along with growing digital ones.

**Stage 3 (`x.x.x`):** Crow generalizes escrowing physical/digital services and products, automating trustless interactions among humans. 

## Run Scripts

### `main.ts`

This script runs a thorouh test on all scripts and how they behave with the smart contract. You will need to keep a Hardhat network and the IPFS daemon running in the background before running this script.

```console
foo@bar:~$ npx hardhat node
foo@bar:~$ ipfs daemon
foo@bar:~$ npx hardhat run scripts/main.ts --network localhost
```
### `Crow.test.ts`

```console
foo@bar:~$ npx hardhat test
```

## Crow's Startup Stage (`0.0.x`): digital-only escrow

The goal we will achieve at this stage is providing a platform for developers and customers of digitally verifiable actions. 

As in the early-stage, assuming Person A wants to have an application that follows some procedure to convert certain inputs to their matching outputs, s/he will set the problem by providing a reward and a list of special/general-case input:output pairs. Crow will take the I:O list, encrypt them, save them on IPFS, and store the returned CID along with the reward on the Ethereum blockchain. Once a programmer wants to tackle the problem s/he will provide their solution as a program file. Crow will check the program with the decrypted I:O to see if the expected outputs are generated by the provided inputs. If that is the case, Crow will swap the reward with the program file(s).

### Summary

- Person A locks X ETH as reward for a software problem and provides expected input:output list on Crow.
- Person B uploads the solution file(s) on Crow.
- Crow check whether the solution generates the required outputs from the provided inputs.
    - If it does, 
        - the code is securely and privately sent to Person A.
        - the reward is transferred to Person B.
    - If it does not and the deadline arrives, reward is returned to Person A.

### Examples

- Math problems
- Web Development
- Software Development

### Competitions

Our competition at this level will be websites like Gitcoin with the key difference that there won't be a necessity for problem setters to confirm and choose winners, bringing more confidence and motivation for the programmers.

## Crow's Growth Stage (`0.x.x`): digital & simple physical service escrow

The goal of this stage is to introduce escrowing on simple physical actions that can be verified digitally.

New functions on new contracts will take the reward, target program, and the required inputs by that program. Once the desired output (or an already-declared approximation of it) meets the conditions defined by the program, Crow approves the service as carried out and the reward gets transferred to the service provider.

As an example, we can think about simple tasks like mobility-as-a-service which can be carried out by applying Uber's confirmation algorithm to Crow's contract, making the whole process of traveling and paying for it, private, trustless, and autonomous.

### Summary

- Simple physical tasks get introduced that are digitally verifiable.
- Person A wants to get this service for X ETH.
- Person B carries out this task.
- Crow gathers necessary info from both people privately and securely.
- Once the task is completed with the requested output (or an approximation of it):
    - Crow tranfers the reward to the service provider
- If the deadlines is met, the reward gets returned to Person A.

### Examples

- Location-based services 
    - Taxi 
    - Shipping and delivery 
    - Review

## Crow's Maturity Stage (`x.x.x`): generalized physical & digital escrow

The eventual first-version vision we are pursuing with Crow through Ethereum is a generalized escrow between the digital and physical worlds. 

The idea is that any person who wants to get something and wants to transfer ETH for it, will be able to lock his ETH on Crow for others to try to provide for his request. The ones trying to solve the problem and get the reward will be doing so without having to trust the problem setter, whether s/he will pay once s/he gets what s/he wanted.

Assuming Person A wants to have a cup of coffee for X ETH with some deadline, s/he sets it as a problem in the Crow. Person B who is a barista and interested in this deal makes a cup of coffee and provides it to Person A. Crow takes notice of every action of these two people in a secure and private manner, and once it is convinced that in the physical world the coffee created by Person B is consumed by Person A, the reward gets transferred to Person B.

### Summary

- Person A locks X ETH as reward for a physical request.
- Person B provides Person A with that request.
- Crow checks wether physical request is fulfilled by analyzing both A and B, securely and privately on decentralized blockchain.
    - Once fulfilled, reward is transferred to Person B.
    - If does not fulfill by some deadline, Person A gets their reward back.
